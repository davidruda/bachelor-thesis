\chapter{Developer documentation} \label{chap:developer_documentation}

\section{Simulator}

The source code for the simulator is located in the \verb|traffic_signaling| directory. Below is an outline of the directory structure:
\begin{itemize}
  \item \texttt{include/} - C++ header files of the simulator
  \begin{itemize}
    \item \texttt{city\_plan/} - headers of \textit{city plan} part
    \item \texttt{simulation/} - headers of \textit{simulation} part
  \end{itemize}

  \item \texttt{src/} - C++ source files of the simulator
  \begin{itemize}
    \item \texttt{city\_plan/} - source files of \textit{city plan} part
    \item \texttt{simulation/} - source files of \textit{simulation} part
    \item \texttt{bindings/} - python bindings for \textit{city plan} and \textit{simulation} parts
  \end{itemize}

  \item \texttt{tests/} - Unit tests for both C++ and Python verifying the simulator functionality

  \item \texttt{traffic\_signaling/} - Contents of the Python package when installed with pip
  \begin{itemize}
    \item \texttt{utils.py} - provides extra utilities and helper functions for the simulator
    \item \texttt{data/} - contains the datasets provided with the competition
  \end{itemize}

  \item \texttt{pyproject.toml}, \texttt{setup.py} - Python configuration files for building and installing the \texttt{traffic-signaling} package using pip

  \item \texttt{CMakeLists.txt} - CMake configuration file for building the C++ code and the Python package using CMake
\end{itemize}
Both the C++ and Python sources are well documented with comments and docstrings to help you understand the code and its functionality.

\bigskip

The simulator is logically divided into two main parts:
\begin{itemize}
    \item \textit{city\_plan} - responsible for loading and storing input data; it essentially represents all ``static'' data known ahead of the simulation; its main class is \verb|CityPlan|
    \item \textit{simulation} - responsible for running the simulation and working with the traffic light schedules; it represents the ``dynamic'' data that change during the simulation; its main class is \verb|Simulation|
\end{itemize}

The motivation behind this separation is to initialize a single \verb|CityPlan| object at the beginning and reuse it across multiple simulations, possibly running in parallel---which is especially useful for the genetic algorithm.

\bigskip

These two parts are compiled into two Python extension modules---\verb|city_plan| and \verb|simulation|---using pybind11\footnote{\url{https://github.com/pybind/pybind11}}. They are then bundled together with the files in the \verb|traffic_signaling| subdirectory into the \verb|traffic-signaling| Python package. For more details about the bindings, see the \verb|bindings/simulation.cpp| and \verb|bindings/city_plan.cpp| files.

\bigskip

Note that when calling C++ code that takes a non-trivial amount of time to run from Python, we release the Python Global Interpreter Lock (GIL)\footnote{\url{https://docs.python.org/3/glossary.html\#term-global-interpreter-lock}}. This allows us to evaluate multiple simulations in parallel using regular threads without blocking the Python interpreter. It eliminates the need for slower and cumbersome multiprocessing, which is the typical approach to run parallel code in Python.

\subsection{Simulation algorithm}

Not only is the simulator implemented in C++ for performance reasons, but it also uses a \textbf{custom event queue algorithm} to ensure the simulation is evaluated as efficiently as possible. Rather than checking all cars every second of the simulation, we use a priority queue of street events sorted by their time of occurrence.

Let us briefly explain how the algorithm works.
As explained in Section~\ref{subsec:cars}, at the beginning of the simulation, all cars are at the end of the first street in their path, waiting for the green light. If there are more cars at the same street, they queue up according to their IDs.

We are at time $0$. For each car, we calculate the \textit{earliest time} it can get the green light on its current street and add it to the street's car queue.
The calculated time depends on the \textit{traffic light schedules} and \textit{other cars already waiting} in the car queue.
For the street, we add an event occurring at the calculated time to the event queue. The event indicates that the front car in the queue can now move to the next street.

Then, we iterate over the event queue until it is empty. We pop the first event from the queue and process it---that is, move the car to the next street and schedule another event at the time the car can get the green light on the next street. If the next street is the car's destination, we can immediately calculate the arrival time and remove the car from the simulation.

Using the event queue allows us to skip all unnecessary checks and reduce the operations to the required minimum, because we only process cars at the times when they are actually moving.
The main loop of the algorithm is implemented in the \verb|simulation/simulation.cpp| file in the \verb|Simulation::run| method. 

\section{Optimization}

The source code for optimization is in two files:
\begin{itemize}
    \item \verb|optimizer.py| - the main script providing the command-line interface for running the optimization algorithms 
    \item \verb|operators.py| - contains the implementation of the optimization algorithms and their operators
\end{itemize}
To implement the optimization algorithms, we used the DEAP\footnote{\url{https://github.com/deap/deap}} library, which provides a modular framework for evolutionary algorithms. However, we tweaked and rewrote some of its functions to suit our needs.

\bigskip

The \verb|optimizer.py| file contains the \verb|Optimizer| class, which is responsible for running the optimization (\verb|run| method). It processes the command-line arguments (described in~Section~\ref{sec:optimization}), initializes the traffic light schedules that we optimize, and runs the optimization algorithm. After the optimization is completed, the results and logs are saved to the specified log directory.

The fitness evaluation for schedules is implemented in the \verb|_evaluate| method.
The schedules initialization is implemented in the \verb|_create_individual| method.
All statistics and logs are handled together by the \verb|_save_statistics| method.

\bigskip

The \verb|operators.py| file contains the tweaked DEAP functions together with other custom functions such as \verb|crossover|, \verb|mutation|, \\
and \verb|tournament_selection_with_elitism|. \\
All three algorithms---\verb|genetic_algorithm|, \verb|hill_climbing|, \\
and \verb|simulated_annealing| functions---are modified versions of the original \verb|eaSimple| function from DEAP, which implements the simple genetic algorithm.

The file contains Cython type hints to enable compilation for faster performance during the optimization.
